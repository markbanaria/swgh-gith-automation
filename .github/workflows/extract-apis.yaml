name: Generate Configs (Cron)

on:
  schedule:
    - cron: '0 10 * * *'
  workflow_dispatch:
    inputs:
      log_level:
        description: 'Log level: 1=DEBUG, 2=INFO, 3=WARNING, 4=ERROR'
        required: false
        default: '2'
      skip_api_linting:
        description: 'Skip the API linting job'
        required: false
        default: 'false'

env:
  SWAGGERHUB_API_KEY: ${{ secrets.SWAGGERHUB_API_KEY }}
  SWAGGERHUB_ORG_NAME: ${{ vars.SWAGGERHUB_ORG_NAME }}

jobs:
fetch-and-group-apis:
  runs-on: ubuntu-latest
  environment: Production

  steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Fetch list of APIs from SwaggerHub
      run: |
        curl -H "Authorization: $SWAGGERHUB_API_KEY" \
             -H "Accept: application/json" \
             "https://api.swaggerhub.com/apis/${{ env.SWAGGERHUB_ORG_NAME }}?limit=100" > swaggerhub_apis.json

    - name: Process and group APIs from SwaggerHub
      id: process_grouped_json
      run: |
        import json, os

        # Load SwaggerHub APIs response
        with open("swaggerhub_apis.json") as file:
            data = json.load(file)

        # Initialize groups
        groups = {
            "PACS": [],
            "PLUK": [],
            "PLAI": [],
            "PVA": [],
            "PAMB": [],
            "Symphony Big Group": []
        }

        symphony_domains = {}  # For domain-based groups

        # Process each API entry
        for api in data['apis']:
            name = api['name']
            properties = {prop['type']: prop.get('value', prop.get('url', '')) for prop in api['properties']}
            url = properties.get("Swagger", "")
            slug = url.split("/")[-2] if url else ""
            latest_version = properties.get("X-Version", "N/A")

            # Skip drafts
            if "(DRAFT)" in name:
                continue

            # Remove "Prudential Symphony" and "API" from name
            formatted_name = name.replace("Prudential Symphony", "").replace("API", "").strip()

            # Determine group
            if "PACS" in name:
                groups["PACS"].append({
                    "name": formatted_name,
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })
            elif "PLUK" in name:
                groups["PLUK"].append({
                    "name": formatted_name,
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })
            elif "PLAI" in name:
                groups["PLAI"].append({
                    "name": formatted_name,
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })
            elif "PVA" in name:
                groups["PVA"].append({
                    "name": formatted_name,
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })
            elif "PAMB" in name:
                groups["PAMB"].append({
                    "name": formatted_name,
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })
            elif "Prudential Symphony API" == name:  # Symphony Big Group
                groups["Symphony Big Group"].append({
                    "name": "Symphony",
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })
            elif "Prudential Symphony" in name:  # Domain-based grouping
                domain = formatted_name
                if domain not in symphony_domains:
                    symphony_domains[domain] = []
                symphony_domains[domain].append({
                    "name": domain,
                    "slug": slug,
                    "latest_version": latest_version,
                    "url": url
                })

        # Merge symphony domains with main groups
        groups.update(symphony_domains)

        # Write the grouped data as JSON string to the environment file for output
        with open(os.getenv("GITHUB_ENV"), "a") as env_file:
            env_file.write(f"grouped_json={json.dumps(groups)}")

generate-folders-and-files:
  runs-on: ubuntu-latest
  environment: Production
  needs: fetch-and-group-apis

  steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Generate folders, files, and grouped_apis.json
      run: |
        import json, os

        # Load grouped JSON data from previous job output
        groups = json.loads('${{ needs.fetch-and-group-apis.outputs.grouped_json }}')

        # Save the consolidated file as grouped_apis.json
        with open("grouped_apis.json", "w") as outfile:
            json.dump(groups, outfile, indent=2)

        # Create folders and files based on grouped data
        for group_name, apis in groups.items():
            folder_path = os.path.join("products", group_name)
            os.makedirs(folder_path, exist_ok=True)

            # Create empty files as placeholders
            with open(os.path.join(folder_path, "manifest.json"), "w") as manifest_file:
                manifest_file.write("{}")

            with open(os.path.join(folder_path, "description.md"), "w") as description_file:
                description_file.write(f"# {group_name}\n")

    - name: Commit grouped_apis.json
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git add grouped_apis.json
        git commit -m "Add consolidated grouped_apis.json file"
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

populate-content:
  runs-on: ubuntu-latest
  environment: Production
  needs: generate-folders-and-files

  steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Populate content in manifest.json and description.md
      run: |
        import json, os

        # Load grouped JSON data from grouped_apis.json
        with open("grouped_apis.json") as file:
            groups = json.load(file)

        # Populate each file with API data
        for group_name, apis in groups.items():
            folder_path = os.path.join("products", group_name)
            
            # Populate manifest.json with metadata for each API
            manifest_content = {
                "productMetadata": {
                    "description": f"Symphony APIs for {group_name}",
                    "slug": f"{group_name.lower()}-api",
                    "public": True,
                    "hidden": False,
                    "logo": "images/icon.png",
                    "logoDark": "images/icon-dark.png",
                    "autoPublish": True,
                    "validateAPIs": True
                },
                "contentMetadata": [
                    {
                        "order": 0,
                        "parent": "",
                        "name": "Description",
                        "slug": "description",
                        "type": "markdown",
                        "contentUrl": "description.md"
                    }
                ]
            }

            # Add each API as a contentMetadata entry
            for i, api in enumerate(apis, start=1):
                manifest_content["contentMetadata"].append({
                    "order": i,
                    "parent": "",
                    "name": api["name"],
                    "slug": api["slug"],
                    "type": "apiUrl",
                    "contentUrl": f"{api['url']}/swagger.json"
                })

            # Write manifest.json with the updated content
            with open(os.path.join(folder_path, "manifest.json"), "w") as manifest_file:
                json.dump(manifest_content, manifest_file, indent=2)

            # Populate description.md with the revised header and list of APIs
            description_content = f"# {group_name} Group\nThis page contains APIs related to {group_name}.\n\n## APIs in this group\n"
            for api in apis:
                description_content += f"- **{api['name']}** (v{api['latest_version']})\n"
            
            with open(os.path.join(folder_path, "description.md"), "w") as description_file:
                description_file.write(description_content)

    - name: Commit generated files
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git add products/
        git commit -m "Generate and populate manifest.json and description.md for each group"
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
